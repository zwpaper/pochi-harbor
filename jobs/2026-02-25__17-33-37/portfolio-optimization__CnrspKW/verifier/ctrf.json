{
    "results": {
        "tool": {
            "name": "pytest",
            "version": "8.4.1"
        },
        "summary": {
            "tests": 4,
            "passed": 1,
            "failed": 3,
            "skipped": 0,
            "pending": 0,
            "other": 0,
            "start": 1772013003.397742,
            "stop": 1772013028.672639
        },
        "tests": [
            {
                "name": "test_outputs.py::test_c_extension_exists",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.0009665970001151436,
                "start": 1772013003.4261982,
                "stop": 1772013003.443252,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "def test_c_extension_exists():\n        \"\"\"Verify that a compiled C extension actually exists\"\"\"\n        try:\n            # Try to import the C extension module\n            sys.path.append(\"/app\")\n>           import portfolio_optimized_c\nE           ModuleNotFoundError: No module named 'portfolio_optimized_c'\n\n/tests/test_outputs.py:39: ModuleNotFoundError\n\nDuring handling of the above exception, another exception occurred:\n\n    def test_c_extension_exists():\n        \"\"\"Verify that a compiled C extension actually exists\"\"\"\n        try:\n            # Try to import the C extension module\n            sys.path.append(\"/app\")\n            import portfolio_optimized_c\n    \n            # Check that it's actually a compiled extension, not pure Python\n            module_file = portfolio_optimized_c.__file__\n            assert module_file is not None, \"C extension module has no file attribute\"\n    \n            # Compiled extensions typically end with .so, .pyd, or similar\n            assert not module_file.endswith(\".py\"), (\n                f\"Expected compiled C extension, but got Python file: {module_file}\"\n            )\n            assert any(module_file.endswith(ext) for ext in [\".so\", \".pyd\", \".dll\"]), (\n                f\"Module doesn't appear to be a compiled extension: {module_file}\"\n            )\n    \n            # Verify the required functions exist\n            assert hasattr(portfolio_optimized_c, \"portfolio_risk_c\"), (\n                \"Missing portfolio_risk_c function\"\n            )\n            assert hasattr(portfolio_optimized_c, \"portfolio_return_c\"), (\n                \"Missing portfolio_return_c function\"\n            )\n    \n        except ImportError as e:\n>           pytest.fail(\n                f\"C extension module not found. Did you run \"\n                f\"'python setup.py build_ext --inplace'? Error: {e}\"\n            )\nE           Failed: C extension module not found. Did you run 'python setup.py build_ext --inplace'? Error: No module named 'portfolio_optimized_c'\n\n/tests/test_outputs.py:62: Failed",
                "message": "The test failed in the call phase"
            },
            {
                "name": "test_outputs.py::test_baseline_functionality",
                "status": "passed",
                "duration": 0.0006090829992899671,
                "start": 1772013003.4434836,
                "stop": 1772013003.4442787,
                "retries": 0,
                "file_path": "test_outputs.py"
            },
            {
                "name": "test_outputs.py::test_correctness_small",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.0021402450001914985,
                "start": 1772013003.4444969,
                "stop": 1772013003.4504645,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "def test_correctness_small():\n        \"\"\"Test correctness on small portfolio\"\"\"\n        # Import from wrapper, which should use the C extension\n        sys.path.append(\"/app\")\n        from portfolio_optimized import portfolio_return_c, portfolio_risk_c\n    \n        weights, cov, returns = generate_test_data(100)\n    \n        # Use protected baseline for comparison\n        risk_python = portfolio_risk_python(weights, cov)\n        return_python = portfolio_return_python(weights, returns)\n    \n>       risk_c = portfolio_risk_c(weights, cov)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:93: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nweights = [0.015277561349280046, 0.013323702074352189, 0.012538212986872976, 0.00997055318802558, 0.018197603223003123, 0.014124438625086912, ...]\ncov_matrix = [[0.03557707193831535, 2.5010755222666935e-05, 0.00027502931836911925, 0.00022321073814882274, 0.0007364712141640124, ...02668251899525428, 0.0008486957344143055, 0.0008831063933001429, 0.0002869137168689272, 0.01882154777295276, ...], ...]\n\n    def portfolio_risk_c(weights, cov_matrix):\n        \"\"\"\n        Calculate portfolio risk using C extension: sqrt(x^T * S * x)\n    \n        Args:\n            weights: Portfolio weights (1D array)\n            cov_matrix: Covariance matrix (2D array)\n        Returns:\n            Portfolio risk (scalar)\n        \"\"\"\n        # TODO: Convert inputs to NumPy arrays and call C extension\n    \n>       raise NotImplementedError(\"TODO: Implement portfolio_risk_c wrapper\")\nE       NotImplementedError: TODO: Implement portfolio_risk_c wrapper\n\nportfolio_optimized.py:18: NotImplementedError",
                "message": "The test failed in the call phase"
            },
            {
                "name": "test_outputs.py::test_performance_and_scalability",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 4.24434423600087,
                "start": 1772013003.4506803,
                "stop": 1772013007.8520322,
                "retries": 2,
                "file_path": "test_outputs.py",
                "tags": [
                    "parametrize::n::[5000, 6000, 8000]"
                ],
                "trace": "n = 8000\n\n    @pytest.mark.parametrize(\"n\", [5000, 6000, 8000])\n    def test_performance_and_scalability(n):\n        \"\"\"Test performance and scalability requirements for large portfolios\"\"\"\n        sys.path.append(\"/app\")\n        from portfolio_optimized import portfolio_return_c, portfolio_risk_c\n    \n        weights, cov, returns = generate_test_data(n)\n    \n        # Test correctness first using protected baseline\n        risk_python = portfolio_risk_python(weights, cov)\n        return_python = portfolio_return_python(weights, returns)\n    \n>       risk_c = portfolio_risk_c(weights, cov)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n/tests/test_outputs.py:117: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nweights = [0.000162310297817993, 0.00021342622519395993, 3.385883356696483e-05, 7.929689458488875e-05, 5.147768911288513e-05, 0.00023678965936467156, ...]\ncov_matrix = [[0.03557707193831535, 2.5010755222666935e-05, 0.00027502931836911925, 0.00022321073814882274, 0.0007364712141640124, ...6244214557796377, 0.0007844576922962113, 3.8451549981415534e-05, 0.0007239180650823003, 0.02677012885932841, ...], ...]\n\n    def portfolio_risk_c(weights, cov_matrix):\n        \"\"\"\n        Calculate portfolio risk using C extension: sqrt(x^T * S * x)\n    \n        Args:\n            weights: Portfolio weights (1D array)\n            cov_matrix: Covariance matrix (2D array)\n        Returns:\n            Portfolio risk (scalar)\n        \"\"\"\n        # TODO: Convert inputs to NumPy arrays and call C extension\n    \n>       raise NotImplementedError(\"TODO: Implement portfolio_risk_c wrapper\")\nE       NotImplementedError: TODO: Implement portfolio_risk_c wrapper\n\nportfolio_optimized.py:18: NotImplementedError",
                "message": "The test failed in the call phase"
            }
        ]
    }
}