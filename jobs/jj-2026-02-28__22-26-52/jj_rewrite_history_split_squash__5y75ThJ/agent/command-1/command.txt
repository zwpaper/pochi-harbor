trap 'rm -rf /tmp/codex-secrets "$CODEX_HOME/auth.json"' EXIT TERM INT; codex exec --dangerously-bypass-approvals-and-sandbox --skip-git-repo-check --model gpt-5.3-codex --json --enable unified_exec -c model_reasoning_effort=high -- 'You are a developer migrating to `jj` and need to clean up some messy history in a repository located at `/home/user/messy-project`.

The current history contains:
1.  An initial commit.
2.  A commit with the description "Add modules" that introduces two files: `math_lib.py` and `string_lib.py`.
3.  A commit with the description "Fix math bug" that corrects an error in `math_lib.py` introduced in the previous commit.

Your goal is to rewrite the history into a clean, linear sequence where the fix is folded into the introduction of the file, and the two files are introduced in separate commits.

**Requirements:**

1.  **Squash** the "Fix math bug" commit into the "Add modules" commit. The resulting commit should contain the correct version of `math_lib.py` and `string_lib.py`.
2.  **Split** that combined commit into two separate commits:
    *   The first commit (parent) should introduce `math_lib.py` (the fixed version). Set its description to "Add math library".
    *   The second commit (child) should introduce `string_lib.py`. Set its description to "Add string library".
3.  The final history should look like: `Initial` -> `Add math library` -> `Add string library`.
4.  Once completed, write the **Change ID** of the final commit (the one adding `string_lib.py`) to a file named `/home/user/final_change_id.txt`. Ensure the file contains *only* the change ID string.

**Note:** You can use `jj split [file]` to split specific file changes into a new child commit.
' 2>&1 </dev/null | tee /logs/agent/codex.txt